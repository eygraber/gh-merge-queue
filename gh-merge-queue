#!/bin/bash
# Configuration
POLL_INTERVAL_SECONDS=30
TIMEOUT_SECONDS=900 # 15 minutes
MUTED=false
DRY_RUN=false
AUTO_MERGE=true
PRE_PUSH_COMMAND=""
MERGE_METHOD="rebase"
GIT_OPERATIONS_PERFORMED=false
NOTIFY_LOOP_DELAY=5
MAX_NOTIFY_LOOP_DELAY=60

function run_command() {
  GIT_OPERATIONS_PERFORMED=true
  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] $1"
    return 0
  fi

  if ! eval "$1"; then
    notify_user "Error executing command: $1" true
    return 1
  fi

  return 0
}

function run_pre_push_command() {
  if [[ -z "$PRE_PUSH_COMMAND" ]]; then
    return
  fi

  echo "Running pre-push command: $PRE_PUSH_COMMAND"
  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] $PRE_PUSH_COMMAND"
    return
  fi

  if ! eval "$PRE_PUSH_COMMAND"; then
    notify_user "Pre-push command failed. Do you want to continue?" true
    while true; do
      read -p "Do you want to continue? (y/n) " yn
      case $yn in
          [Yy]* ) break;;
          [Nn]* ) exit;;
          * ) echo "Please answer yes or no.";;
      esac
    done
  fi
}

function notify_user() {
  message="$1"
  loop_until_confirmed="$2"
  delay=$NOTIFY_LOOP_DELAY

  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] Notify: $message"
    return
  else
    echo "$message"
  fi

  while true; do
    if [[ "$(uname)" == "Darwin" ]]; then
      osascript -e "display notification \"$message\" with title \"gh-merge-queue\""
    elif command -v notify-send &> /dev/null; then
      notify-send "gh-merge-queue" "$message"
    fi

    play_notification_sound

    if [[ "$loop_until_confirmed" != true ]]; then
      break
    fi

    echo "Press any key to continue..."
    read -t $delay -n 1 -s
    if [ $? -eq 0 ]; then
      break
    fi

    delay=$((delay + NOTIFY_LOOP_DELAY))
    if [ $delay -gt $MAX_NOTIFY_LOOP_DELAY ]; then
      delay=$MAX_NOTIFY_LOOP_DELAY
    fi
  done
}

function play_notification_sound() {
  if [[ "$MUTED" = false ]]; then
    for i in {1..3}; do
      if [[ "$(uname)" == "Darwin" ]]; then
        afplay /System/Library/Sounds/Sosumi.aiff &> /dev/null || true
      else
        paplay /usr/share/sounds/freedesktop/stereo/message.oga &> /dev/null || true
      fi
      sleep 0.5
    done
  fi
}

function cleanup() {
  if [[ "$GIT_OPERATIONS_PERFORMED" = true ]]; then
    echo "Cleaning up..."
    if ! run_command "git fetch -p -P"; then exit 1; fi
    if ! run_command "git remote prune origin"; then exit 1; fi
    if ! run_command "git gc"; then exit 1; fi
  fi
}

trap cleanup EXIT

function show_help() {
  echo "Usage: $(basename "$0") [options] <last-branch>"
  echo "Options:"
  echo "  --timeout <seconds>      Timeout for waiting for a pull request to be merged (default: 900)."
  echo "  --poll-interval <seconds>  Interval for polling the pull request status (default: 30)."
  echo "  --muted                  Disable the notification sound."
  echo "  --dry-run                Print the commands that would be executed without running them."
  echo "  --[no-]auto-merge        Enable or disable auto-merge for the pull requests (default: enabled)."
  echo "  --pre-push-command <cmd> Command to run before pushing to GitHub."
  echo "  --merge-method <method>  Merge method to use (squash, rebase, or merge). Default: rebase."
  echo "  --help                   Show this help message."
}

function load_config() {
  CONFIG_FILE=""
  if [[ -f ".github/.gh-merge-queue" ]]; then
    CONFIG_FILE=".github/.gh-merge-queue"
  elif [[ -f ".gh-merge-queue" ]]; then
    CONFIG_FILE=".gh-merge-queue"
  fi

  if [[ -n "$CONFIG_FILE" ]]; then
    echo "Loading config from $CONFIG_FILE"
    while read -r line || [[ -n "$line" ]]; do
      if [[ "$line" =~ ^\s*([a-zA-Z0-9_-]+)\s*=\s*(.*)\s*$ ]]; then
        key="${BASH_REMATCH[1]}"
        value="${BASH_REMATCH[2]}"

        # remove surrounding quotes from value if any
        if [[ "${value:0:1}" == '"' && "${value: -1}" == '"' ]]; then
            value="${value:1:-1}"
        elif [[ "${value:0:1}" == "'" && "${value: -1}" == "'" ]]; then
            value="${value:1:-1}"
        fi

        case "$key" in
          "timeout") TIMEOUT_SECONDS="$value" ;;
          "poll-interval") POLL_INTERVAL_SECONDS="$value" ;;
          "muted") MUTED="$value" ;;
          "auto-merge") AUTO_MERGE="$value" ;;
          "pre-push-command") PRE_PUSH_COMMAND="$value" ;;
          "merge-method") MERGE_METHOD="$value" ;;
        esac
      fi
    done < "$CONFIG_FILE"
  fi
}

# Parse command-line arguments
load_config
LAST_BRANCH=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    --timeout)
      TIMEOUT_SECONDS="$2"
      shift 2
      ;;
    --poll-interval)
      POLL_INTERVAL_SECONDS="$2"
      shift 2
      ;;
    --muted)
      MUTED=true
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --auto-merge)
      AUTO_MERGE=true
      shift
      ;;
    --no-auto-merge)
      AUTO_MERGE=false
      shift
      ;;
    --pre-push-command)
      PRE_PUSH_COMMAND="$2"
      shift 2
      ;;
    --merge-method)
      if [[ "$2" != "squash" && "$2" != "rebase" && "$2" != "merge" ]]; then
        echo "Error: Invalid merge method. Must be one of: squash, rebase, merge." >&2
        exit 1
      fi
      MERGE_METHOD="$2"
      shift 2
      ;;
    --help)
      show_help
      exit 0
      ;;
    *)
      if [[ -z "$LAST_BRANCH" ]]; then
        LAST_BRANCH="$1"
        shift
      else
        echo "Invalid option: $1" >&2
        show_help
        exit 1
      fi
      ;;
  esac
done

if [[ -z "$LAST_BRANCH" ]]; then
  echo "Error: Missing last branch name." >&2
  show_help
  exit 1
fi

# Check for gh CLI
if ! command -v gh &> /dev/null; then
  notify_user "Error: gh CLI is not installed. Please install it to use this script." false
  exit 1
fi

# Check for gh auth status
if ! gh auth status &> /dev/null; then
  notify_user "Error: Not logged in to GitHub. Please run 'gh auth login'." false
  exit 1
fi

# Check for jq
if ! command -v jq &> /dev/null; then
  notify_user "Error: jq is not installed. Please install it to use this script." false
  exit 1
fi

MAIN_BRANCH=$(gh repo view --json defaultBranchRef -q .defaultBranchRef.name)
if [[ -z "$MAIN_BRANCH" ]]; then
  notify_user "Error: Could not determine the default branch for this repository." false
  exit 1
fi

echo "Using main branch: $MAIN_BRANCH"

# Build the list of branches
BRANCHES=()
CURRENT_BRANCH="$LAST_BRANCH"
while [[ "$CURRENT_BRANCH" != "$MAIN_BRANCH" ]]; do
  BRANCHES+=("$CURRENT_BRANCH")
  CURRENT_BRANCH=$(gh pr view "$CURRENT_BRANCH" --json baseRefName -q .baseRefName)
  if [[ -z "$CURRENT_BRANCH" ]]; then
    notify_user "Error: Could not find pull request for branch '$LAST_BRANCH'." false
    exit 1
  fi
done

# Reverse the order of the branches
for i in $(seq 0 $((${#BRANCHES[@]} - 1))); do
  REVERSED_BRANCHES[i]="${BRANCHES[${#BRANCHES[@]}-i-1]}"
done

BRANCHES=("${REVERSED_BRANCHES[@]}")

echo "The following branches will be processed in order:"
for BRANCH in "${BRANCHES[@]}"; do
  echo "  - $BRANCH"
done

if ! run_command "git checkout \"$MAIN_BRANCH\"" ; then
  notify_user "Error: Couldn't checkout \"$MAIN_BRANCH\"" true
  exit 1;
fi

if ! run_command "git pull -r" ; then
  notify_user "Error: git pull -r failed" true
  exit 1;
fi

# Loop through the pull requests and process them
for BRANCH in "${BRANCHES[@]}"; do
  NOTIFY_LOOP_DELAY=5 # Reset notification delay for each branch

  echo "Processing pull request branch: $BRANCH"

  if ! run_command "git checkout \"$BRANCH\"" ; then
    notify_user "Error: Couldn't checkout \"$BRANCH\"" true
    exit 1;
  fi

  if ! run_command "git rebase \"$MAIN_BRANCH\"" ; then
    notify_user "Error: git rebase \"$MAIN_BRANCH\" failed" true
    exit 1;
  fi

  run_pre_push_command

  if ! run_command "git push --force-with-lease" ; then
    notify_user "Error: git push --force-with-lease failed" true
    exit 1;
  fi

  PR_URL=$(gh pr view "$BRANCH" --json url -q .url)
  if [[ -z "$PR_URL" ]]; then
    notify_user "Error: Could not get pull request URL for branch '$BRANCH'." true
    exit 1
  fi

  if [[ "$AUTO_MERGE" = true ]]; then
    AUTO_MERGE_STATUS=$(gh pr view "$PR_URL" --json autoMergeRequest -q .autoMergeRequest)
    if [[ -z "$AUTO_MERGE_STATUS" ]]; then
      echo "Enabling auto-merge for pull request $PR_URL"
      run_command "gh pr merge \"$PR_URL\" --auto --$MERGE_METHOD"
    fi
  fi

  echo "Waiting for pull request $PR_URL to be merged..."
  START_TIME=$(date +%s)
  while true; do
    if [[ "$DRY_RUN" = true ]]; then
      echo "[DRY RUN] Checking PR status..."
      break
    fi
    STATE=$(gh pr view "$PR_URL" --json state -q .state)
    if [[ "$STATE" == "MERGED" ]]; then
      echo "Pull request $PR_URL has been merged."
      break
    fi

    if [[ "$STATE" == "CLOSED" ]]; then
      notify_user "Error: Pull request $PR_URL has been closed without merging." true
      exit 1
    fi

    CHECKS_STATUS=$(gh pr view "$PR_URL" --json statusCheckRollup -q '.statusCheckRollup | map(select(.status == "COMPLETED" and .conclusion != "SUCCESS" and .conclusion != "SKIPPED" and .conclusion != null)) | length')
    if [[ "$CHECKS_STATUS" -gt 0 ]]; then
      notify_user "Error: Some checks have failed for pull request $PR_URL." true
      exit 1
    fi

    AUTO_MERGE_STATUS=$(gh pr view "$PR_URL" --json autoMergeRequest -q .autoMergeRequest)
    if [[ -z "$AUTO_MERGE_STATUS" ]]; then
        notify_user "Pull request $PR_URL is ready to be merged, but auto-merge is disabled." true
    fi

    REVIEW_DECISION=$(gh pr view "$PR_URL" --json reviewDecision -q .reviewDecision)
    if [[ "$REVIEW_DECISION" == "REVIEW_REQUIRED" || "$REVIEW_DECISION" == "CHANGES_REQUESTED" ]]; then
      notify_user "Pull request $PR_URL is waiting for approval." true
    fi

    ELAPSED_TIME=$(( $(date +%s) - START_TIME ))
    if (( ELAPSED_TIME > TIMEOUT_SECONDS )); then
      notify_user "Error: Timeout waiting for pull request $PR_URL to be merged." true
      exit 1
    fi

    sleep "$POLL_INTERVAL_SECONDS"
  done

  if ! run_command "git checkout \"$MAIN_BRANCH\"" ; then
    notify_user "Error: Couldn't checkout \"$MAIN_BRANCH\"" true
    exit 1;
  fi

  if ! run_command "git pull -r" ; then
    notify_user "Error: git pull -r failed" true
    exit 1;
  fi

  if ! run_command "git branch -D \"$BRANCH\"" ; then
    notify_user "Error: git branch -D \"$BRANCH\" failed" true
    exit 1;
  fi

  echo "Branch '$BRANCH' has been deleted."
done

notify_user "All pull requests have been processed." false

