#!/bin/bash
# Configuration
POLL_INTERVAL_SECONDS=30
TIMEOUT_SECONDS=900 # 15 minutes
MUTED=false
DRY_RUN=false
FAIL_ON_OUT_OF_DATE=false
AUTO_MERGE=true
PRE_PUSH_COMMAND=""
MERGE_METHOD=""
USER_MERGE_METHOD=""
GIT_OPERATIONS_PERFORMED=false
NOTIFY_LOOP_DELAY=5
MAX_NOTIFY_LOOP_DELAY=60
RETRY_FLAKY_CHECKS=""

function run_command() {
  GIT_OPERATIONS_PERFORMED=true
  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] $1"
    return 0
  fi

  if ! eval "$1"; then
    notify_user "Error executing command: $1" true
    return 1
  fi

  return 0
}

function run_pre_push_command() {
  if [[ -z "$PRE_PUSH_COMMAND" ]]; then
    return
  fi

  echo "Running pre-push command: $PRE_PUSH_COMMAND"
  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] $PRE_PUSH_COMMAND"
    return
  fi

  if ! eval "$PRE_PUSH_COMMAND"; then
    notify_user "Pre-push command failed. Do you want to continue?" true
    while true; do
      read -p "Do you want to continue? (y/n) " yn
      case $yn in
          [Yy]* ) break;;
          [Nn]* ) exit;;
          * ) echo "Please answer yes or no.";;
      esac
    done
  fi
}

function notify_user() {
  message="$1"
  loop_until_confirmed="$2"
  delay=$NOTIFY_LOOP_DELAY

  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] Notify: $message"
    return
  else
    echo "$message"
  fi

  while true; do
    if [[ "$(uname)" == "Darwin" ]]; then
      osascript -e "display notification \"$message\" with title \"gh-merge-queue\""
    elif command -v notify-send &> /dev/null; then
      notify-send "gh-merge-queue" "$message"
    fi

    play_notification_sound

    if [[ "$loop_until_confirmed" != true ]]; then
      break
    fi

    echo "Press any key to continue..."
    read -t $delay -n 1 -s
    if [ $? -eq 0 ]; then
      break
    fi

    delay=$((delay + NOTIFY_LOOP_DELAY))
    if [ $delay -gt $MAX_NOTIFY_LOOP_DELAY ]; then
      delay=$MAX_NOTIFY_LOOP_DELAY
    fi
  done
}

function play_notification_sound() {
  if [[ "$MUTED" = false ]]; then
    for i in {1..3}; do
      if [[ "$(uname)" == "Darwin" ]]; then
        afplay /System/Library/Sounds/Sosumi.aiff &> /dev/null || true
      else
        paplay /usr/share/sounds/freedesktop/stereo/message.oga &> /dev/null || true
      fi
      sleep 0.5
    done
  fi
}

function cleanup() {
  if [[ "$GIT_OPERATIONS_PERFORMED" = true ]]; then
    echo "Cleaning up..."
    if ! run_command "git fetch -p -P"; then exit 1; fi
    if ! run_command "git remote prune origin"; then exit 1; fi
    if ! run_command "git gc"; then exit 1; fi
  fi
}

trap cleanup EXIT

function get_allowed_merge_methods() {
  ALLOWED_MERGE_METHODS=()
  local methods
  methods=$(gh repo view --json rebaseMergeAllowed,squashMergeAllowed,mergeCommitAllowed -q '[(.rebaseMergeAllowed | tostring), (.squashMergeAllowed | tostring), (.mergeCommitAllowed | tostring)] | @json')
  if [[ -z "$methods" ]]; then
      notify_user "Error: Could not determine any allowed merge methods for this repository. Check your 'gh' CLI version and permissions." false
      exit 1
  fi

  if echo "$methods" | jq -e '.[0] == "true"' > /dev/null; then
    ALLOWED_MERGE_METHODS+=("rebase")
  fi
  if echo "$methods" | jq -e '.[1] == "true"' > /dev/null; then
    ALLOWED_MERGE_METHODS+=("squash")
  fi
  if echo "$methods" | jq -e '.[2] == "true"' > /dev/null; then
    ALLOWED_MERGE_METHODS+=("merge")
  fi

  if [ ${#ALLOWED_MERGE_METHODS[@]} -eq 0 ]; then
    notify_user "Error: No merge methods are enabled for this repository." false
    exit 1
  fi
}

function determine_merge_method() {
  local user_merge_method=$1

  if [[ -n "$user_merge_method" ]]; then
    # User provided a merge method
    local is_allowed=false
    for allowed_method in "${ALLOWED_MERGE_METHODS[@]}"; do
      if [[ "$allowed_method" == "$user_merge_method" ]]; then
        is_allowed=true
        break
      fi
    done

    if [[ "$is_allowed" == true ]]; then
      MERGE_METHOD="$user_merge_method"
    else
      notify_user "Error: Merge method '$user_merge_method' is not enabled for this repository. Allowed methods are: ${ALLOWED_MERGE_METHODS[*]}" false
      exit 1
    fi
  else
    # User did not provide a merge method, so we determine the best one.
    if [[ ${#ALLOWED_MERGE_METHODS[@]} -eq 1 ]]; then
      MERGE_METHOD="${ALLOWED_MERGE_METHODS[0]}"
    elif [[ " ${ALLOWED_MERGE_METHODS[@]} " =~ " rebase " ]]; then
      MERGE_METHOD="rebase"
    elif [[ " ${ALLOWED_MERGE_METHODS[@]} " =~ " squash " ]]; then
      MERGE_METHOD="squash"
    elif [[ " ${ALLOWED_MERGE_METHODS[@]} " =~ " merge " ]]; then
      MERGE_METHOD="merge"
    else
      # This case should be handled by get_allowed_merge_methods, but just in case.
      notify_user "Error: No suitable merge method found." false
      exit 1
    fi
  fi
}

function show_help() {
  echo "Usage: $(basename "$0") [options] <last-branch>"
  echo "Options:"
  echo "  --timeout <seconds>      Timeout for waiting for a pull request to be merged (default: 900)."
  echo "  --poll-interval <seconds>  Interval for polling the pull request status (default: 30)."
  echo "  --muted                  Disable the notification sound."
  echo "  --dry-run                Print the commands that would be executed without running them."
  echo "  --[no-]auto-merge        Enable or disable auto-merge for the pull requests (default: enabled)."
  echo "  --pre-push-command <cmd> Command to run before pushing to GitHub."
  echo "  --merge-method <method>  Merge method to use (squash, rebase, or merge). Default: rebase."
  echo "  --fail-on-out-of-date    Fail the queue if a PR is out of date, instead of rebasing."
  echo "  --retry-flaky-checks[=<csv>] Retry flaky checks. If no value is provided, any failed check is retried. Otherwise, a comma-separated list of check names to retry."
  echo "  --help                   Show this help message."
}

function load_config() {
  CONFIG_FILE=""
  if [[ -f ".github/.gh-merge-queue" ]]; then
    CONFIG_FILE=".github/.gh-merge-queue"
  elif [[ -f ".gh-merge-queue" ]]; then
    CONFIG_FILE=".gh-merge-queue"
  fi

  if [[ -n "$CONFIG_FILE" ]]; then
    echo "Loading config from $CONFIG_FILE"
    while read -r line || [[ -n "$line" ]]; do
      if [[ "$line" =~ ^\s*([a-zA-Z0-9_-]+)\s*=\s*(.*)\s*$ ]]; then
        key="${BASH_REMATCH[1]}"
        value="${BASH_REMATCH[2]}"

        # remove surrounding quotes from value if any
        if [[ "${value:0:1}" == '"' && "${value: -1}" == '"' ]]; then
            value="${value:1:-1}"
        elif [[ "${value:0:1}" == "'" && "${value: -1}" == "'" ]]; then
            value="${value:1:-1}"
        fi

        case "$key" in
          "timeout") TIMEOUT_SECONDS="$value" ;;
          "poll-interval") POLL_INTERVAL_SECONDS="$value" ;;
          "muted") MUTED="$value" ;;
          "auto-merge") AUTO_MERGE="$value" ;;
          "pre-push-command") PRE_PUSH_COMMAND="$value" ;;
          "merge-method") USER_MERGE_METHOD="$value" ;;
        esac
      fi
done < "$CONFIG_FILE"
  fi
}

# Parse command-line arguments
load_config
LAST_BRANCH=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    --timeout)
      TIMEOUT_SECONDS="$2"
      shift 2
      ;; 
    --poll-interval)
      POLL_INTERVAL_SECONDS="$2"
      shift 2
      ;; 
    --muted)
      MUTED=true
      shift
      ;; 
    --dry-run)
      DRY_RUN=true
      shift
      ;; 
    --auto-merge)
      AUTO_MERGE=true
      shift
      ;; 
    --no-auto-merge)
      AUTO_MERGE=false
      shift
      ;; 
    --pre-push-command)
      PRE_PUSH_COMMAND="$2"
      shift 2
      ;; 
    --merge-method)
      USER_MERGE_METHOD="$2"
      shift 2
      ;; 
    --fail-on-out-of-date)
      FAIL_ON_OUT_OF_DATE=true
      shift
      ;; 
    --retry-flaky-checks*)
      if [[ "$1" == *=* ]]; then
        RETRY_FLAKY_CHECKS="${1#*=}"
      else
        RETRY_FLAKY_CHECKS="true"
      fi
      shift
      ;; 
    --help)
      show_help
      exit 0
      ;; 
    *)
      if [[ -z "$LAST_BRANCH" ]]; then
        LAST_BRANCH="$1"
        shift
      else
        echo "Invalid option: $1" >&2
        show_help
        exit 1
      fi
      ;; 
  esac
done

if [[ -z "$LAST_BRANCH" ]]; then
  echo "Error: Missing last branch name." >&2
  show_help
  exit 1
fi

# Check for gh CLI
if ! command -v gh &> /dev/null; then
  notify_user "Error: gh CLI is not installed. Please install it to use this script." false
  exit 1
fi

# Check for gh auth status
if ! gh auth status &> /dev/null; then
  notify_user "Error: Not logged in to GitHub. Please run 'gh auth login'." false
  exit 1
fi

# Check for jq
if ! command -v jq &> /dev/null; then
  notify_user "Error: jq is not installed. Please install it to use this script." false
  exit 1
fi

get_allowed_merge_methods
determine_merge_method "$USER_MERGE_METHOD"

MAIN_BRANCH=$(gh repo view --json defaultBranchRef -q .defaultBranchRef.name)
if [[ -z "$MAIN_BRANCH" ]]; then
  notify_user "Error: Could not determine the default branch for this repository." false
  exit 1
fi

echo "Using main branch: $MAIN_BRANCH"

# Build the list of branches
BRANCHES=()
CURRENT_BRANCH="$LAST_BRANCH"
while [[ "$CURRENT_BRANCH" != "$MAIN_BRANCH" ]]; do
  BRANCHES+=("$CURRENT_BRANCH")
  CURRENT_BRANCH=$(gh pr view "$CURRENT_BRANCH" --json baseRefName -q .baseRefName)
  if [[ -z "$CURRENT_BRANCH" ]]; then
    notify_user "Error: Could not find pull request for branch '$LAST_BRANCH'." false
    exit 1
  fi
done

# Reverse the order of the branches
for i in $(seq 0 $((${#BRANCHES[@]} - 1))); do
  REVERSED_BRANCHES[i]="${BRANCHES[${#BRANCHES[@]}-i-1]}"
done

BRANCHES=("${REVERSED_BRANCHES[@]}")

echo "The following branches will be processed in order:"
for BRANCH in "${BRANCHES[@]}"; do
  echo "  - $BRANCH"
done

if ! run_command "git checkout \"$MAIN_BRANCH\"" ; then
  notify_user "Error: Couldn't checkout \"$MAIN_BRANCH\"" true
  exit 1;
fi

if ! run_command "git pull -r" ; then
  notify_user "Error: git pull -r failed" true
  exit 1;
fi

# Loop through the pull requests and process them
for BRANCH in "${BRANCHES[@]}"; do
  NOTIFY_LOOP_DELAY=5 # Reset notification delay for each branch

  echo "Processing pull request branch: $BRANCH"

  BASE_BRANCH_HASH=$(git rev-parse "origin/$MAIN_BRANCH")
  MERGE_BASE_HASH=$(git merge-base "origin/$MAIN_BRANCH" "origin/$BRANCH")

  if [[ "$BASE_BRANCH_HASH" != "$MERGE_BASE_HASH" ]]; then
    if [[ "$FAIL_ON_OUT_OF_DATE" = true ]]; then
      notify_user "Error: Pull request for branch '$BRANCH' is out of date." true
      exit 1
    else
      notify_user "Pull request for branch '$BRANCH' is out of date. Rebasing and force-pushing." false
    fi
  fi

  if ! run_command "git checkout \"$BRANCH\"" ; then
    notify_user "Error: Couldn't checkout \"$BRANCH\"" true
    exit 1;
  fi

  if ! run_command "git rebase \"$MAIN_BRANCH\"" ; then
    notify_user "Error: git rebase \"$MAIN_BRANCH\" failed" true
    exit 1;
  fi

  run_pre_push_command

  LOCAL_HEAD=$(git rev-parse HEAD)
  REMOTE_HEAD=$(git rev-parse origin/"$BRANCH" 2>/dev/null || echo "") # Handle case where remote branch doesn't exist yet

  if [[ "$LOCAL_HEAD" == "$REMOTE_HEAD" ]]; then
    echo "Local and remote heads are the same. Amending commit to trigger remote update."
    if ! run_command "git commit --amend --no-edit" ; then
      notify_user "Error: git commit --amend --no-edit failed" true
      exit 1;
    fi
  else
    echo "Local and remote heads differ. No need to amend commit."
  fi

  if ! run_command "git push --force-with-lease" ; then
    notify_user "Error: git push --force-with-lease failed" true
    exit 1;
  fi

  sleep 5 # Give GitHub a few seconds to update the PR status

  PR_URL=$(gh pr view "$BRANCH" --json url -q .url)
  if [[ -z "$PR_URL" ]]; then
    notify_user "Error: Could not get pull request URL for branch '$BRANCH'." true
    exit 1
  fi

  if [[ "$AUTO_MERGE" = true ]]; then
    AUTO_MERGE_STATUS=$(gh pr view "$PR_URL" --json autoMergeRequest -q .autoMergeRequest)
    if [[ -z "$AUTO_MERGE_STATUS" ]]; then
      echo "Enabling auto-merge for pull request $PR_URL"
      run_command "gh pr merge \"$PR_URL\" --auto --$MERGE_METHOD"
    fi
  fi

  echo "Waiting for pull request $PR_URL to be merged..."
  START_TIME=$(date +%s)
  while true; do
    if [[ "$DRY_RUN" = true ]]; then
      echo "[DRY RUN] Checking PR status..."
      break
    fi
    STATE=$(gh pr view "$PR_URL" --json state -q .state)
    if [[ "$STATE" == "MERGED" ]]; then
      echo "Pull request $PR_URL has been merged."
      break
    fi

    if [[ "$STATE" == "CLOSED" ]]; then
      notify_user "Error: Pull request $PR_URL has been closed without merging." true
      exit 1
    fi

    if [[ -n "$RETRY_FLAKY_CHECKS" ]]; then
      REPO_NWO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
      COMMIT_SHA=$(gh pr view "$PR_URL" --json headRefOid -q .headRefOid)
      FAILED_CHECKS_JSON=$(gh api "repos/$REPO_NWO/commits/$COMMIT_SHA/check-runs" -q '.check_runs | map(select(.conclusion == "failure"))')
      FAILED_CHECKS_COUNT=$(echo "$FAILED_CHECKS_JSON" | jq 'length')

      if [[ "$FAILED_CHECKS_COUNT" -gt 0 ]]; then
        if [[ "$RETRY_FLAKY_CHECKS" != "true" ]]; then
          FLAKY_CHECKS_LIST=(${RETRY_FLAKY_CHECKS//,/ })
          FAILED_CHECKS_NAMES=$(echo "$FAILED_CHECKS_JSON" | jq -r '.[].name')

          NON_FLAKY_FAILURES=()
          for check in $FAILED_CHECKS_NAMES; do
            is_flaky=false
            for flaky_check in "${FLAKY_CHECKS_LIST[@]}"; do
              if [[ "$check" == "$flaky_check" ]]; then
                is_flaky=true
                break
              fi
            done
            if [[ "$is_flaky" == false ]]; then
              NON_FLAKY_FAILURES+=("$check")
            fi
          done

          if [[ ${#NON_FLAKY_FAILURES[@]} -gt 0 ]]; then
            notify_user "Error: The following non-flaky checks have failed for pull request $PR_URL: ${NON_FLAKY_FAILURES[*]}" true
            exit 1
          fi
        fi

        echo "Some checks have failed. Retrying..."
        FAILED_RUN_IDS=$(echo "$FAILED_CHECKS_JSON" | jq -r '.[].id')
        WORKFLOW_RUN_IDS=()
        for run_id in $FAILED_RUN_IDS; do
          CHECK_SUITE_ID=$(gh api "repos/$REPO_NWO/check-runs/$run_id" -q '.check_suite.id')
          WORKFLOW_RUN_ID=$(gh api "repos/$REPO_NWO/actions/runs?check_suite_id=$CHECK_SUITE_ID" -q '.workflow_runs[0].id')
          if [[ -n "$WORKFLOW_RUN_ID" ]]; then
            WORKFLOW_RUN_IDS+=("$WORKFLOW_RUN_ID")
          else
            echo "Could not find workflow run for check run $run_id"
          fi
        done

        UNIQUE_WORKFLOW_RUN_IDS=$(echo "${WORKFLOW_RUN_IDS[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')
        if [[ -n "$UNIQUE_WORKFLOW_RUN_IDS" ]]; then
          for workflow_run_id in $UNIQUE_WORKFLOW_RUN_IDS; do
            echo "Retrying failed jobs for workflow run with ID: $workflow_run_id"
            gh run rerun "$workflow_run_id" --failed
          done
          START_TIME=$(date +%s)
        fi
      fi
    else
      CHECKS_STATUS=$(gh pr view "$PR_URL" --json statusCheckRollup -q '.statusCheckRollup | map(select(.status == "COMPLETED" and .conclusion != "SUCCESS" and .conclusion != "SKIPPED" and .conclusion != null)) | length')
      if [[ "$CHECKS_STATUS" -gt 0 ]]; then
        notify_user "Error: Some checks have failed for pull request $PR_URL." true
        exit 1
      fi
    fi

    AUTO_MERGE_STATUS=$(gh pr view "$PR_URL" --json autoMergeRequest -q .autoMergeRequest)
    if [[ -z "$AUTO_MERGE_STATUS" ]]; then
        notify_user "Pull request $PR_URL is ready to be merged, but auto-merge is disabled." true
    fi

    REVIEW_DECISION=$(gh pr view "$PR_URL" --json reviewDecision -q .reviewDecision)
    if [[ "$REVIEW_DECISION" == "REVIEW_REQUIRED" || "$REVIEW_DECISION" == "CHANGES_REQUESTED" ]]; then
      notify_user "Pull request $PR_URL is waiting for approval." true
    fi

    ELAPSED_TIME=$(( $(date +%s) - START_TIME ))
    if (( ELAPSED_TIME > TIMEOUT_SECONDS )); then
      notify_user "Error: Timeout waiting for pull request $PR_URL to be merged." true
      exit 1
    fi

    sleep "$POLL_INTERVAL_SECONDS"
  done

  if ! run_command "git checkout \"$MAIN_BRANCH\"" ; then
    notify_user "Error: Couldn't checkout \"$MAIN_BRANCH\"" true
    exit 1;
  fi

  if ! run_command "git pull -r" ; then
    notify_user "Error: git pull -r failed" true
    exit 1;
  fi

  if ! run_command "git branch -D \"$BRANCH\"" ; then
    notify_user "Error: git branch -D \"$BRANCH\" failed" true
    exit 1;
  fi

  echo "Branch '$BRANCH' has been deleted."
done

notify_user "All pull requests have been processed." false

