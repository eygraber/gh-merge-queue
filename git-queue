#!/bin/bash
set -e

# Configuration
POLL_INTERVAL_SECONDS=30
TIMEOUT_SECONDS=900 # 15 minutes
MUTED=false
DRY_RUN=false
AUTO_MERGE=true
PRE_PUSH_COMMAND=""
GIT_OPERATIONS_PERFORMED=false
BELL_DELAY=5
MAX_BELL_DELAY=60

function run_command() {
  GIT_OPERATIONS_PERFORMED=true
  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] $1"
  else
    eval "$1"
  fi
}

function notify_user() {
  if [[ "$DRY_RUN" = true ]]; then
    echo "[DRY RUN] Notify: $1"
    return
  fi
  if [[ "$(uname)" == "Darwin" ]]; then
    osascript -e "display notification \"$1\" with title \"git-queue\""
  elif command -v notify-send &> /dev/null; then
    notify-send "git-queue" "$1"
  else
    echo -e "\a"
  fi
}

function ring_bell() {
  if [[ "$MUTED" = false ]]; then
    echo -e "\a"
    sleep "$BELL_DELAY"
    if (( BELL_DELAY < MAX_BELL_DELAY )); then
      BELL_DELAY=$((BELL_DELAY + 5))
    fi
  fi
}

function cleanup() {
  if [[ "$GIT_OPERATIONS_PERFORMED" = true ]]; then
    echo "Cleaning up..."
    run_command "git fetch -p -P"
    run_command "git remote prune origin"
    run_command "git gc"
  fi
}

trap cleanup EXIT

function show_help() {
  echo "Usage: $(basename "$0") [options] <last-branch>"
  echo "Options:"
  echo "  --timeout <seconds>    Timeout for waiting for a pull request to be merged (default: 900)."
  echo "  --poll-interval <seconds>  Interval for polling the pull request status (default: 30)."
  echo "  --muted                  Disable the bell sound."
  echo "  --dry-run                Print the commands that would be executed without running them."
  echo "  --[no-]auto-merge        Enable or disable auto-merge for the pull requests (default: enabled)."
  echo "  --pre-push-command <cmd> Command to run before pushing to GitHub."
  echo "  --help                   Show this help message."
}

function prompt_user_for_approval() {
  while true; do
    read -p "Do you want to continue polling for approvals? (y/n) " yn
    case $yn in
        [Yy]* ) break;;
        [Nn]* ) exit;;
        * ) echo "Please answer yes or no.";;
    esac
done
}

# Parse command-line arguments
LAST_BRANCH=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    --timeout)
      TIMEOUT_SECONDS="$2"
      shift 2
      ;; 
    --poll-interval)
      POLL_INTERVAL_SECONDS="$2"
      shift 2
      ;; 
    --muted)
      MUTED=true
      shift
      ;; 
    --dry-run)
      DRY_RUN=true
      shift
      ;; 
    --auto-merge)
      AUTO_MERGE=true
      shift
      ;; 
    --no-auto-merge)
      AUTO_MERGE=false
      shift
      ;; 
    --pre-push-command)
      PRE_PUSH_COMMAND="$2"
      shift 2
      ;; 
    --help)
      show_help
      exit 0
      ;; 
    *)
      if [[ -z "$LAST_BRANCH" ]]; then
        LAST_BRANCH="$1"
        shift
      else
        echo "Invalid option: $1" >&2
        show_help
        exit 1
      fi
      ;; 
  esac
done

if [[ -z "$LAST_BRANCH" ]]; then
  echo "Error: Missing last branch name." >&2
  show_help
  exit 1
fi

# Check for gh CLI
if ! command -v gh &> /dev/null; then
  echo "Error: gh CLI is not installed. Please install it to use this script."
  notify_user "Error: gh CLI is not installed. Please install it to use this script."
  exit 1
fi

# Check for gh auth status
if ! gh auth status &> /dev/null; then
  echo "Error: Not logged in to GitHub. Please run 'gh auth login'."
  notify_user "Error: Not logged in to GitHub. Please run 'gh auth login'."
  exit 1
fi

MAIN_BRANCH=$(gh repo view --json defaultBranchRef -q .defaultBranchRef.name)
if [[ -z "$MAIN_BRANCH" ]]; then
  echo "Error: Could not determine the default branch for this repository."
  notify_user "Error: Could not determine the default branch for this repository."
  exit 1
fi
echo "Using main branch: $MAIN_BRANCH"

# Build the list of branches
BRANCHES=()
CURRENT_BRANCH="$LAST_BRANCH"
while [[ "$CURRENT_BRANCH" != "$MAIN_BRANCH" ]]; do
  BRANCHES+=("$CURRENT_BRANCH")
  CURRENT_BRANCH=$(gh pr view "$CURRENT_BRANCH" --json baseRefName -q .baseRefName)
  if [[ -z "$CURRENT_BRANCH" ]]; then
    echo "Error: Could not find pull request for branch '$LAST_BRANCH'."
    notify_user "Error: Could not find pull request for branch '$LAST_BRANCH'."
    exit 1
  fi
done

# Reverse the order of the branches
for i in $(seq 0 $((${#BRANCHES[@]} - 1))); do
  REVERSED_BRANCHES[i]="${BRANCHES[${#BRANCHES[@]}-i-1]}"
done
BRANCHES=("${REVERSED_BRANCHES[@]}")

echo "The following branches will be processed in order:"
for BRANCH in "${BRANCHES[@]}"; do
  echo "  - $BRANCH"
done

run_command "git fetch --all --prune"

# Loop through the pull requests and process them
for BRANCH in "${BRANCHES[@]}"; do
  BELL_DELAY=5 # Reset bell delay for each branch
  echo "Processing pull request branch: $BRANCH"
  run_command "git checkout \"$BRANCH\""
  run_command "git rebase \"$MAIN_BRANCH\""
  if [[ -n "$PRE_PUSH_COMMAND" ]]; then
    echo "Running pre-push command: $PRE_PUSH_COMMAND"
    run_command "$PRE_PUSH_COMMAND"
  fi
  run_command "git push --force-with-lease"

  PR_URL=$(gh pr view --json url -q .url)
  if [[ -z "$PR_URL" ]]; then
    echo "Error: Could not get pull request URL for branch '$BRANCH'."
    notify_user "Error: Could not get pull request URL for branch '$BRANCH'."
    exit 1
  fi

  if [[ "$AUTO_MERGE" = true ]]; then
    AUTO_MERGE_STATUS=$(gh pr view "$PR_URL" --json autoMergeRequest -q .autoMergeRequest)
    if [[ -z "$AUTO_MERGE_STATUS" ]]; then
      echo "Enabling auto-merge for pull request $PR_URL"
      run_command "gh pr merge \"$PR_URL\" --auto --squash"
    fi
  fi

  echo "Waiting for pull request $PR_URL to be merged..."
  START_TIME=$(date +%s)
  while true; do
    if [[ "$DRY_RUN" = true ]]; then
      echo "[DRY RUN] Checking PR status..."
      break
    fi
    STATE=$(gh pr view "$PR_URL" --json state -q .state)
    if [[ "$STATE" == "MERGED" ]]; then
      echo "Pull request $PR_URL has been merged."
      break
    fi

    if [[ "$STATE" == "CLOSED" ]]; then
      echo "Error: Pull request $PR_URL has been closed without merging."
      notify_user "Error: Pull request $PR_URL has been closed without merging."
      ring_bell
      continue
    fi

    CHECKS_STATUS=$(gh pr checks "$PR_URL" --json conclusion -q '[.[] | select(.conclusion != "SUCCESS" and .conclusion != "SKIPPED" and .conclusion != null)] | length')
    if [[ "$CHECKS_STATUS" -gt 0 ]]; then
      echo "Error: Some checks have failed for pull request $PR_URL."
      notify_user "Error: Some checks have failed for pull request $PR_URL."
      ring_bell
      continue
    fi

    AUTO_MERGE_STATUS=$(gh pr view "$PR_URL" --json autoMergeRequest -q .autoMergeRequest)
    if [[ -z "$AUTO_MERGE_STATUS" ]]; then
        echo "Pull request $PR_URL is ready to be merged, but auto-merge is disabled."
        notify_user "Pull request $PR_URL is ready to be merged, but auto-merge is disabled."
        ring_bell
    fi

    REVIEW_DECISION=$(gh pr view "$PR_URL" --json reviewDecision -q .reviewDecision)
    if [[ "$REVIEW_DECISION" == "REVIEW_REQUIRED" || "$REVIEW_DECISION" == "CHANGES_REQUESTED" ]]; then
      echo "Pull request $PR_URL is waiting for approval."
      notify_user "Pull request $PR_URL is waiting for approval."
      prompt_user_for_approval
    fi

    ELAPSED_TIME=$(( $(date +%s) - START_TIME ))
    if (( ELAPSED_TIME > TIMEOUT_SECONDS )); then
      echo "Error: Timeout waiting for pull request $PR_URL to be merged."
      notify_user "Error: Timeout waiting for pull request $PR_URL to be merged."
      ring_bell
      continue
    fi

    sleep "$POLL_INTERVAL_SECONDS"
  done

  run_command "git checkout \"$MAIN_BRANCH\""
  run_command "git pull"
  run_command "git branch -D \"$BRANCH\""
  echo "Branch '$BRANCH' has been deleted."
done

echo "All pull requests have been processed."
notify_user "All pull requests have been processed."